## DEPTH FIRST SEARCH
Typically a graph problem. A tree structure, going through the trees. 
e.g. a string and searchin through characters. Transform something into a tree and search.
e.g. Start at a starting point, go to the end, go back to the beginning, go through another tree.

## BREADTH FIRST SEARCH
BFS vs DFS: DFS adds nodes to a stack and takes last child off the top and visits its children, etc. BFS does the opposite. BFS uses a queue that adds child nodes, grab first one added, add the first one added and add all its children to the end of the queue.

## MATCHING BRACKET PROBLEM
Given a bunch of brackets, find if the string of brackets is valid or find the next valid bracket to add.
Solution: Typically to use a stack where you add the last opening bracket to a stack and match whenever you find a closing bracket.

## ** HASH TABLES **
Given a 2D array. Traverse this and keep track of what you've already visited in a matrix. What datastructure is used?

## VARIABLES/POINTERS MANIPULATION
A common need for algorithms. Traversing a string from Right to Left and Left to Right. Requires knowing manipulating multiple variables/pointers. 
Keeping track of a lot of variables in your head and tracking precisely.
e.g. Find the longest palendromic substring in a string. Usually done by traversing the string. Every letter expand two pointers that expand outwards. from this, determing if you are dealing with a palindrome. 

## *** REVERSE LINKED LIST *** (duplicates, removing duplicates) 
Typically uses 3 different pointers. 

## SORTING FUNAMENTALS (quicksort, mergesort, bubblesort techniques, runtime of a sort, time space complexity)
Understanding sorting algorithms concepts and how quicksort mergesort is faster than bubblesort.) Knowing how your O(nlog(n)) affects your algorithm. Different sorts can make runtime of algorithms better or worse. 

## RECURSION
Not necessarily practical, however it lends itself to understanding problem solving. Be familiar with how it works. 

## CUSTOM DATA STRUCTURES (O-Oriented Programming)


## BINARY SEARCH
